diff --git a/src/sat/interpolants/cadical_tracer.cpp b/src/sat/interpolants/cadical_tracer.cpp
index 6b250b46..86d65604 100644
--- a/src/sat/interpolants/cadical_tracer.cpp
+++ b/src/sat/interpolants/cadical_tracer.cpp
@@ -53,7 +53,7 @@ get_var_label(const std::unordered_map<int64_t, VariableKind> &var_labels,
 /* CaDiCaL::Tracer interface ------------------------------------------------ */
 
 void
-CadicalTracer::add_original_clause(uint64_t id,
+CadicalTracer::add_original_clause(int64_t id,
                                    bool redundant,
                                    const std::vector<int32_t> &clause,
                                    bool restore)
@@ -86,10 +86,11 @@ CadicalTracer::add_original_clause(uint64_t id,
 }
 
 void
-CadicalTracer::add_derived_clause(uint64_t id,
+CadicalTracer::add_derived_clause(int64_t id,
                                   bool redundant,
+                                  int witness,
                                   const std::vector<int32_t> &clause,
-                                  const std::vector<uint64_t> &antecedents)
+                                  const std::vector<int64_t> &antecedents)
 {
   if (d_logger.is_log_enabled(2))
   {
@@ -109,15 +110,16 @@ CadicalTracer::add_derived_clause(uint64_t id,
 
   (void) id;
   (void) redundant;
+  (void) witness;
   assert(!antecedents.empty());
   assert(d_clauses.size() == id);
   d_clauses.emplace_back(clause, ClauseType::DERIVED, 0, antecedents);
 }
 
 void
-CadicalTracer::add_assumption_clause(uint64_t id,
+CadicalTracer::add_assumption_clause(int64_t id,
                                      const std::vector<int32_t> &clause,
-                                     const std::vector<uint64_t> &antecedents)
+                                     const std::vector<int64_t> &antecedents)
 {
   if (d_logger.is_log_enabled(2))
   {
@@ -133,7 +135,7 @@ CadicalTracer::add_assumption_clause(uint64_t id,
   if (antecedents.size())
   {
     // We have a resolution of multiple clauses.
-    add_derived_clause(id, true, clause, antecedents);
+    add_derived_clause(id, true, 0, clause, antecedents);
   }
   else
   {
@@ -159,7 +161,7 @@ CadicalTracer::add_assumption_clause(uint64_t id,
 }
 
 void
-CadicalTracer::delete_clause(uint64_t id,
+CadicalTracer::delete_clause(int64_t id,
                              bool redundant,
                              const std::vector<int32_t> &clause)
 {
@@ -205,7 +207,7 @@ CadicalTracer::add_constraint(const std::vector<int> &clause)
 void
 CadicalTracer::reset_assumptions()
 {
-  for (uint64_t id : d_assumption_clauses)
+  for (int64_t id : d_assumption_clauses)
   {
     d_clauses[id].d_clause.clear();
     d_clauses[id].d_type   = ClauseType::NONE;
@@ -217,7 +219,7 @@ CadicalTracer::reset_assumptions()
 
 void
 CadicalTracer::conclude_unsat(CaDiCaL::ConclusionType conclusion,
-                              const std::vector<uint64_t> &clause_ids)
+                              const std::vector<int64_t> &clause_ids)
 {
   (void) conclusion;
   assert(conclusion != CaDiCaL::ConclusionType::CONSTRAINT);
@@ -242,12 +244,12 @@ CadicalTracer::conclude_unsat(CaDiCaL::ConclusionType conclusion,
   d_conclusion = conclusion;
   d_proof_core.clear();
   d_final_clause_ids = clause_ids;
-  std::vector<uint64_t> visit{clause_ids};
+  std::vector<int64_t> visit{clause_ids};
   std::vector<bool> visited(d_clauses.size(), false);
   // Compute proof core by tracing back from final clause ids
   while (!visit.empty())
   {
-    uint64_t id = visit.back();
+    int64_t id = visit.back();
     visit.pop_back();
     if (!visited[id])
     {
@@ -272,7 +274,7 @@ CadicalTracer::get_interpolant(
         &term_labels)
 {
   d_part_interpolants.clear();
-  uint64_t final_clause_id = d_final_clause_ids[0];
+  int64_t final_clause_id = d_final_clause_ids[0];
 
   if (d_logger.is_log_enabled(2))
   {
@@ -345,7 +347,7 @@ CadicalTracer::get_interpolant(
     Log(2);
   }
 
-  for (uint64_t id : d_proof_core)
+  for (int64_t id : d_proof_core)
   {
     assert(id <= d_clauses.size());
     const auto &clause = d_clauses[id];
diff --git a/src/sat/interpolants/cadical_tracer.h b/src/sat/interpolants/cadical_tracer.h
index ac21a0a1..6fd1e1ef 100644
--- a/src/sat/interpolants/cadical_tracer.h
+++ b/src/sat/interpolants/cadical_tracer.h
@@ -37,7 +37,7 @@ class CadicalTracer : public Tracer
     Clause(const std::vector<int32_t> &clause,
            ClauseType type,
            int64_t aig_id,
-           const std::vector<uint64_t> &antecedents = {})
+           const std::vector<int64_t> &antecedents = {})
         : d_clause(clause),
           d_type(type),
           d_aig_id(aig_id),
@@ -53,7 +53,7 @@ class CadicalTracer : public Tracer
     int64_t d_aig_id = 0;
 
     /** Antecedents of this clause in the proof. */
-    std::vector<uint64_t> d_antecedents;
+    std::vector<int64_t> d_antecedents;
   };
   struct Interpolant
   {
@@ -69,21 +69,22 @@ class CadicalTracer : public Tracer
 
   /* CaDiCaL::Tracer interface ------------------------------------------- */
 
-  void add_original_clause(uint64_t id,
+  void add_original_clause(int64_t id,
                            bool redundant,
                            const std::vector<int32_t> &clause,
                            bool restore = false) override;
 
-  void add_derived_clause(uint64_t id,
+  void add_derived_clause(int64_t id,
                           bool redundant,
+                          int witness,
                           const std::vector<int32_t> &clause,
-                          const std::vector<uint64_t> &proof_chain) override;
+                          const std::vector<int64_t> &proof_chain) override;
 
-  void add_assumption_clause(uint64_t id,
+  void add_assumption_clause(int64_t id,
                              const std::vector<int32_t> &clause,
-                             const std::vector<uint64_t> &proof_chain) override;
+                             const std::vector<int64_t> &proof_chain) override;
 
-  void delete_clause(uint64_t id,
+  void delete_clause(int64_t id,
                      bool redundant,
                      const std::vector<int32_t> &clause) override;
 
@@ -94,7 +95,7 @@ class CadicalTracer : public Tracer
   void reset_assumptions() override;
 
   void conclude_unsat(CaDiCaL::ConclusionType conclusion,
-                      const std::vector<uint64_t> &clause_ids) override;
+                      const std::vector<int64_t> &clause_ids) override;
 
   /* --------------------------------------------------------------------- */
 
@@ -182,15 +183,15 @@ class CadicalTracer : public Tracer
   /** The currently active assumptions. */
   std::unordered_set<int32_t> d_assumptions;
   /** The clauses observed via add_assumption_clause(). */
-  std::vector<uint64_t> d_assumption_clauses;
+  std::vector<int64_t> d_assumption_clauses;
   /**
    * The partial interpolants, dummy at index 0 to enable access via clause id.
    */
-  std::unordered_map<uint64_t, Interpolant> d_part_interpolants = {
+  std::unordered_map<int64_t, Interpolant> d_part_interpolants = {
       {0, Interpolant()}};
 
-  std::vector<uint64_t> d_final_clause_ids;
-  std::vector<uint64_t> d_proof_core;
+  std::vector<int64_t> d_final_clause_ids;
+  std::vector<int64_t> d_proof_core;
   CaDiCaL::ConclusionType d_conclusion;
 
   /** The configured interpolants generation algorithm. */
